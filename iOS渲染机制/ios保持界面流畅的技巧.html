<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>iOS 保持界面流畅的技巧</title>

</head>
<body>
<h1>iOS 保持界面流畅的技巧</h1>

<p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a>，这篇文章很干货，下面内容是做笔记。</p>

<ol>
<li><p>iOS卡顿的原因。
 <img src="ios_screen_display.png" alt="" />
 CPU计算好需要显示的内容，提交给GPU，GPU渲染好后，提交给帧缓冲区。<br/>
 <img src="ios_screen_scan.png" alt="" />
 <img src="ios_vsync_off.jpg" alt="" />
 为了解决帧缓冲区的读写冲突问题，设计了两个缓冲区，一个用于读，一个用于写，并且用显示器的V-Sync信号，作为两个缓冲区的橘色切换。
 <img src="ios_frame_drop.png" alt="" />
 如果V-Sync信号来了，新的渲染结果，还没有写入到缓冲区，就会出现掉帧的情况。</p></li>
<li><p>列出可以优化的关键点</p>

<ul>
<li>CPU层面：优化计算量

<ul>
<li>对象创建<br/>
使用轻量对象</li>
<li>对象调整，消息传递<br/>
尽量减少调整</li>
<li>对象销毁<br/>
放到后台线程。<br/>
上面说的三点，因为UI和CA层对象不是线程安全的，对他们的操纵和访问，不能放到后台线程。</li>
<li>布局计算</li>
<li>autolayout</li>
<li>文本高度、宽度计算 <br/>
上面说的几点，可以通过缓存计算结果来优化，避免重复计算</li>
<li>文本在coretext层渲染，高度和宽度又会计算一遍<br/>
用 TextKit 或最底层的 CoreText 对文本异步绘制。</li>
<li>图片解码<br/>
这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能</li>
<li>CoreGraphic层绘制<br/>
放到后台绘制好后，然后异步交给主线程</li>
</ul>
</li>
<li>GPU层面：优化接受纹理、顶点描述、变换、混合、渲染、输出到屏幕上的过程

<ul>
<li>业务上避免过多图片的设计</li>
<li>在cpu那里，可以将多个图层合成为一个图层</li>
<li>图片像素和屏幕像素要匹配，图片不要超过gpu的最大承受力</li>
<li>不透明的视图，表名apaue，避免无用的alpha通道合成</li>
<li>避免使用圆角、阴影、遮罩等属性，尝试设置shouldRasterize将这部分工作转到cpu，或者用其他手段，达到相同的视觉效果。</li>
</ul>
</li>
</ul>
</li>
<li><p>ASDK架构
ASDK 认为，阻塞主线程的任务，主要分为</p>

<ul>
<li>文本高度计算、视图布局计算</li>
<li>文本渲染、图片解码、图形绘制</li>
<li>UIKit Objects的创建、调整、销毁</li>
</ul>


<p> 文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。<strong>ASDK 的目标，就是尽量把这些任务从主线程挪走（利用多核），而挪不走的，就尽量优化性能（利用合成，减少UIView和CALayer的创建）</strong>。 <br/>
ASDK是重新实现封装了一些控件，这些控件和UIKit的控件一一对应，但内部却是基于CoreAnimation层和UIKit层重新实现的。 <br/>
UIKit和CoreAnimation关系：
<img src="asdk_layer_backed_view.png" alt="" />·chr
需要响应动作时，ASDK封装UIKit，用来实现
<img src="asdk_view_backed_node.png" alt="" />
不需要响应动作时，ASDK封装CoreAnimation
<img src="asdk_layer_backed_node.png" alt="" /></p></li>
<li><p>ASDK实现</p>

<ol>
<li><p>ASDispalyNode是线程安全的，他重新实现了大部分UI控件，实现了上述的优化关键点。比如：</p>

<ol>
<li>当多个视图叠加时，不需要响应事件的视图，会合成为图片，减少了UIView和CALayer的创建，从而减轻CPU和GPU负担。<br/>
注意设置backed</li>
<li>异步并发，将可以放到后台线程做的事情，移除主线程。
比如布局计算、排版、解码等，封装成较小的任务，并利用GCD异步并发执行</li>
</ol>
</li>
<li><p> runloop 任务分发<br/>
Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。<br/>
ASDK 在此处模拟了 Core Animation 的这个机制：所有针对 ASNode 的修改和提交，总有些任务是必需放入主线程执行的。当出现这种任务时，ASNode 会把任务用 ASAsyncTransaction(Group) 封装并提交到一个全局的容器去。ASDK 也在 RunLoop 中注册了一个 Observer，监视的事件和 CA 一样，但优先级比 CA 要低。当 RunLoop 进入休眠前、CA 处理完事件后，ASDK 就会执行该 loop 内提交的所有任务。具体代码见这个文件：ASAsyncTransactionGroup。<br/>
<strong>通过这种机制，ASDK 可以在合适的机会把异步、并发的操作同步到主线程去，并且能获得不错的性能。</strong></p></li>
</ol>
</li>
<li><p>做了一个Demo，从CPU层面进行优化。</p></li>
</ol>

</body>
</html>