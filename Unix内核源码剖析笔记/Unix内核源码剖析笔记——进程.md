#Unix内核源码剖析笔记——进程
##进程
###什么是进程：

内核采用进程的概念对执行中的程序进行管理。一个进程对应一个执行中的程序。  
在执行程序时，内核首先将程序读入内存，然后将此内存区域分配给进程。进程拥有独立的虚拟地址空间，可以使用虚拟地址空间内的地址（虚拟地址），有MMU转换为实际的内存地址（物理地址），访问被分配的内存。   
进程具有唯一的进程ID。由于是以ID为识别手段，因此即使同一程序被执行多次生成多个进程，内核也将识别为不同的进程。  
此外，由于内存以进程为单位分配，而且进程的虚拟地址空间各自独立，因此各个进程在执行时不会相互影响。  
由于程序的指令在执行时不会发生变化，因此从节约内存使用量的角度出发，有时也会将同一块内存分配给多个进程的虚拟地址空间。  

图
。
。。。。。。。
####进程的并行执行：  

Unix v6可供多名用户同时使用。每名用户可同时执行多个程序，因此在任意时刻，系统可存在多个进程。  
由于只有一个CPU，即使存在多个进程，实际上只有一个处于执行状态，其他进程处于待机状态。  

图。。。。。。

内核会随时切换执行中的进程，将时间片分给不同的进程。即使有1个cpu，也可以并行处理多个程序。这种方式称为分时系统。 

图。。。。。。


####进程的执行状态： 
可分为执行状态和休眠状态。  
进程在等待其他资源被释放或等待周边设备处理结束时，会暂时中断自身处理，进入休眠状态。内核从处于可执行状态的进程中选1个作为执行进程运行。  

图。。。。。。。  

####用户模式和内核模式：  
处理器有两种模式：用户模式和内核模式。  
切换模式时，映射到虚拟地址的物理内存区域也随之变换。  
虚拟地址在用户模式时映射到用户程序内存，在内核模式时则映射到内核程序内存。  
内核程序在系统启动时被读取到内存中。  

####交换处理：  
随着进程增多会导致内存容量不足。内核定期将处于休眠状态，重要度较低的进程所需的数据，从内存转移到交换空间，或者将交换空间中已处于可执行状态的进程数据恢复到内存。称为交换处理，由系统启动时生成的进程执行。  

###为进程分配内存
代码段和数据段作为两个连续的物理内存区域被分配给进程。进程通过虚拟地址访问被分配的物理内存区域。  

####代码段  
代码段是只读的。各进程共享同一个代码段。  
####数据段  
数据段存放变量等数据。不能被共享。  
数据段物理地址和长度由proc.p_addr和proc.p_size表示。  
  
图。。。。

* PPDA(Per Process Data Area)  
	*  user结构体和内核栈区域构成
	*  1kb。用户空间无法访问
	*  内核区域被用作内核处理的临时工作区。 
	
* 数据区域
	*  存放全局变量或bss等静态变量的区域和进程用了动态管理内存的堆区域构成。
	*  扩展区域需要通过系统调用来完成。  
	
* 栈区域  
	* 用来暂时存放函数的参数或局部数据。  

###虚拟地址空间  
* 每个进程·都拥有独立的虚拟地址空间。举例涞水，某个进程的虚拟地址A和其他进程的虚拟地址A所指向的物理地址是不同的。但是进程间共享代码段时不受此限制。  
图。。。。。2-10  

* 使用虚拟地址有以下优点  
	*  程序能够使用以任意地址为起点的内存空间  
	*  实现对内存访问的管理
	*  提高内存使用效率  

##进程的管理 1  
###进程的生命周期  
1.某个进程通过系统调用fork，创建一个用于执行程序的进程。生成此进程的进程称为父进程，被生成的进程称为子进程。子进程通过赋值父进程的数据得以创建。   
2.父进程执行系统调用wait，进入等待状态直到子进程处理结束。  
3.当控制权转移到子进程后，子进程通过系统调用exec将程序读取到内存并开始执行。  
4.当程序执行完毕后，子进程通过系统调用exit结束自身运行并进入僵尸状态，控制权交回父进程。
5.父进程得到子进程的执行结果后清理子进程。  
  
图3-1.。。。。  

###创建进程  
####进程的复制   
通过将父进程的数据复制的子进程，以此创建新的进程。  
 
####父进程和子进程  
图3-3  

父进程和子进程具有以下特点。  
* 各进程拥有1个父进程和0个以上的子进程
* 父进程在子进程结束时，取其结束状态并释放子进程资源  
* 子进程继承了父进程打开的文件和当前目录等数据  
* 子进程和父进程共享代码段。但子进程执行其他程序，这种共享关系被解除  
* 父子进程各自独立，因此他们具有独立的数据段，执行时不会相互影响。  

###切换执行进程   

####中断执行进程  
执行进程在执行内核函数sleep()后，进入休眠状态并中断当前处理。此后，由于swtch()被调用，执行进程发生切换。  
  
图3-6  

内核函数sleep()一般在下述情况下被调用。  

 * 用户程序访问系统调用wait  
 * 等待周边设施处理完毕  
 * 等待使用中的资源被释放  
 
 只有处于可执行状态的进程才有机会称为执行进程。处于休眠状态的进程除非该状态被解除，否则无法再次被执行。  
 
####上下文切换  
执行进程被中断时，将当前执行状态保存于user结构体中。当被中断的进程再次执行时，通过user结构体回复以前的执行状态。这个处理被称为上下文切换。  

####系统调用wait  
用户程序执行系统调用wait后，该进程的执行将被中断，控制权转交给其他进程。  
wait具有以下两个功能。  
1.中断当前进程等待子进程执行结束。  
2.清理执行结束的子进程。   

###执行程序  
执行程序时，首先需要将该程序的执行文件从块设备读取至内存，并将其配置到执行进程的虚拟地址空间中。  
系统调用exec用于执行程序执行文件的读入处理和分配内存的处理  
系统调用exec不会改变已打开文件和当前目录的数据。父进程的数据按原状保留。  

####进程的终止  
当程序执行完毕后，该进程的运行将被终止，被其占用的资源也会释放。  
进程的终止处理包括以下两个步骤：  
1.用户执行系统调用exit，使进程进入僵尸状态（SZOMB）。也将user结构体换出至交换空间，同时释放被其占用的内存。  
2.父进程通过执行系统调用wait取得子进程的完结状态，并负责清理处于僵尸状态的子进程。    


###数据区域的扩展  
####系统调用break  
系统调用break用来扩展或缩小数据段中数据区域的长度。供用户程序调用C语言库函数malloc()等使用break实现对堆区域的扩展等操作。位于虚拟地址空间的数据区域后部的地址称为break。系统调用break的用途可以看做是调整break的位置。  
图3-20  
.。.。
。
。
。

数据区域的扩展和缩小通过expand()进行.伴随数据区域的扩展和缩小，栈区域的位置也会发生变化。  

##交换处理  
###什么是交换处理  
执行程序是必须将代码和数据读入内存。内存速度快，但容量小。随着进程增多，内存无法容纳所有程序的代码和数据。  
因此，内核通过定期执行交换处理，将处于休眠和优先级较低的进程从内存移至速度慢但容量大的磁盘等交换空间（换出swap out），当进程成为可执行状态是，再移回内存（swap in）。  
通过交换处理，只有马上需要执行的进程才会存在于内存中，可以更有效的利用有限的内存资源。同时也可以避免内存容量的限制，以并列方式执行更多进程。  
图 4-1 。。。。   

###代码段和数据段  
对于代码段，当代码段读入内存后，交换空间的代码会保留。当进程执行结束或被换出内存是，如果代码daunt不再被内存中的任何进程所参照，则会从内存中释放。  
相反，对数据段进行换入,换出处理时，作为处理对象的数据将从原有设备上释放。  

图4-2 。。。。。。  
 
 
###共享代码段的处理  
代码段是用来容纳程序指令的只读区域。因为指令不会发生变化，所以如果某个程序同时存在多个运行中的进程，这些进程将共享同一段代码段。这样可以节约内存的使用量。   










	